"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.defaultPropagatorFactory = exports.defaultSpanProcessorFactory = exports.splunkSpanExporterFactory = exports.jaegerSpanExporterFactory = exports.otlpSpanExporterFactory = exports.resolveTracesExporter = exports._setDefaultOptions = void 0;
/*
 * Copyright Splunk Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const assert = require("assert");
const util = require("util");
const propagator_b3_1 = require("@opentelemetry/propagator-b3");
const instrumentations_1 = require("./instrumentations");
const exporter_collector_grpc_1 = require("@opentelemetry/exporter-collector-grpc");
// eslint-disable-next-line node/no-extraneous-import
const grpc_js_1 = require("@grpc/grpc-js");
const exporter_jaeger_1 = require("@opentelemetry/exporter-jaeger");
const resource_1 = require("./resource");
const semantic_conventions_1 = require("@opentelemetry/semantic-conventions");
const api_1 = require("@opentelemetry/api");
const core_1 = require("@opentelemetry/core");
const SplunkBatchSpanProcessor_1 = require("./SplunkBatchSpanProcessor");
const resources_1 = require("@opentelemetry/resources");
const defaultServiceName = 'unnamed-node-service';
function _setDefaultOptions(options = {}) {
    var _a, _b;
    process.env.OTEL_SPAN_LINK_COUNT_LIMIT =
        (_a = process.env.OTEL_SPAN_LINK_COUNT_LIMIT) !== null && _a !== void 0 ? _a : '1000';
    process.env.OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT =
        (_b = process.env.OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT) !== null && _b !== void 0 ? _b : '12000';
    options.accessToken =
        options.accessToken || process.env.SPLUNK_ACCESS_TOKEN || '';
    if (options.serverTimingEnabled === undefined) {
        options.serverTimingEnabled = getEnvBoolean('SPLUNK_TRACE_RESPONSE_HEADER_ENABLED', true);
    }
    const extraTracerConfig = options.tracerConfig || {};
    let resource = new resource_1.EnvResourceDetector().detect();
    const serviceName = options.serviceName ||
        process.env.OTEL_SERVICE_NAME ||
        resource.attributes[semantic_conventions_1.SemanticResourceAttributes.SERVICE_NAME];
    if (!serviceName) {
        api_1.diag.warn('service.name attribute is not set, your service is unnamed and will be difficult to identify. ' +
            'Set your service name using the OTEL_RESOURCE_ATTRIBUTES environment variable. ' +
            'E.g. OTEL_RESOURCE_ATTRIBUTES="service.name=<YOUR_SERVICE_NAME_HERE>"');
    }
    resource = resource.merge(new resources_1.Resource({
        [semantic_conventions_1.SemanticResourceAttributes.SERVICE_NAME]: serviceName || defaultServiceName,
    }));
    const tracerConfig = Object.assign({ resource }, extraTracerConfig);
    // factories
    if (options.spanExporterFactory === undefined) {
        options.spanExporterFactory = resolveTracesExporter();
    }
    options.spanProcessorFactory =
        options.spanProcessorFactory || defaultSpanProcessorFactory;
    options.propagatorFactory =
        options.propagatorFactory || defaultPropagatorFactory;
    // instrumentations
    if (options.instrumentations === undefined) {
        options.instrumentations = (0, instrumentations_1.getInstrumentations)();
    }
    if (options.instrumentations.length === 0) {
        api_1.diag.warn('No instrumentations set to be loaded. Install an instrumentation package to enable auto-instrumentation.');
    }
    if (options.captureHttpRequestUriParams === undefined) {
        options.captureHttpRequestUriParams = [];
    }
    return {
        endpoint: options.endpoint,
        serviceName: String(resource.attributes[semantic_conventions_1.SemanticResourceAttributes.SERVICE_NAME]),
        accessToken: options.accessToken,
        serverTimingEnabled: options.serverTimingEnabled,
        instrumentations: options.instrumentations,
        tracerConfig: tracerConfig,
        spanExporterFactory: options.spanExporterFactory,
        spanProcessorFactory: options.spanProcessorFactory,
        propagatorFactory: options.propagatorFactory,
        captureHttpRequestUriParams: options.captureHttpRequestUriParams,
    };
}
exports._setDefaultOptions = _setDefaultOptions;
function resolveTracesExporter() {
    const factory = SpanExporterMap[process.env.OTEL_TRACES_EXPORTER || 'default'];
    assert.strictEqual(typeof factory, 'function', `Invalid value for OTEL_TRACES_EXPORTER env variable: ${util.inspect(process.env.OTEL_TRACES_EXPORTER)}. Pick one of ${util.inspect(Object.keys(SpanExporterMap), {
        compact: true,
    })} or leave undefined.`);
    return factory;
}
exports.resolveTracesExporter = resolveTracesExporter;
function otlpSpanExporterFactory(options) {
    const metadata = new grpc_js_1.Metadata();
    if (options.accessToken) {
        // for forward compatibility, is not currently supported
        metadata.set('X-SF-TOKEN', options.accessToken);
    }
    return new exporter_collector_grpc_1.CollectorTraceExporter({
        url: options.endpoint,
        metadata,
    });
}
exports.otlpSpanExporterFactory = otlpSpanExporterFactory;
function genericJaegerSpanExporterFactory(defaultEndpoint, options) {
    var _a, _b;
    const jaegerOptions = {
        serviceName: options.serviceName,
        endpoint: (_b = (_a = options.endpoint) !== null && _a !== void 0 ? _a : process.env.OTEL_EXPORTER_JAEGER_ENDPOINT) !== null && _b !== void 0 ? _b : defaultEndpoint,
        tags: [],
        username: '',
        password: '',
    };
    if (options.accessToken) {
        jaegerOptions.username = 'auth';
        jaegerOptions.password = options.accessToken;
    }
    return new exporter_jaeger_1.JaegerExporter(jaegerOptions);
}
exports.jaegerSpanExporterFactory = genericJaegerSpanExporterFactory.bind(null, 'http://localhost:14268/v1/traces');
exports.splunkSpanExporterFactory = genericJaegerSpanExporterFactory.bind(null, 'http://localhost:9080/v1/trace');
const SpanExporterMap = {
    default: otlpSpanExporterFactory,
    'jaeger-thrift-http': exports.jaegerSpanExporterFactory,
    'jaeger-thrift-splunk': exports.splunkSpanExporterFactory,
    otlp: otlpSpanExporterFactory,
    'otlp-grpc': otlpSpanExporterFactory,
};
function defaultSpanProcessorFactory(options) {
    return new SplunkBatchSpanProcessor_1.SplunkBatchSpanProcessor(options.spanExporterFactory(options));
}
exports.defaultSpanProcessorFactory = defaultSpanProcessorFactory;
// eslint-disable-next-line @typescript-eslint/no-unused-vars
function defaultPropagatorFactory(options) {
    var _a;
    const propagatorsStr = (_a = process.env.OTEL_PROPAGATORS) !== null && _a !== void 0 ? _a : 'tracecontext,baggage';
    assert.equal(typeof propagatorsStr, 'string', 'Expecting OTEL_PROPAGATORS environment variable to be a comma-delimited string.');
    const propagators = [];
    for (const propagator of deduplicate(propagatorsStr.split(','))) {
        switch (propagator) {
            case 'baggage':
                propagators.push(new core_1.W3CBaggagePropagator());
                break;
            case 'tracecontext':
                propagators.push(new core_1.W3CTraceContextPropagator());
                break;
            case 'b3multi':
                propagators.push(new propagator_b3_1.B3Propagator({ injectEncoding: propagator_b3_1.B3InjectEncoding.MULTI_HEADER }));
                break;
            case 'b3':
                propagators.push(new propagator_b3_1.B3Propagator());
                break;
        }
    }
    return new core_1.CompositePropagator({
        propagators,
    });
}
exports.defaultPropagatorFactory = defaultPropagatorFactory;
function getEnvBoolean(key, defaultValue = true) {
    const value = process.env[key];
    if (value === undefined) {
        return defaultValue;
    }
    if (['false', 'no', '0'].indexOf(value.trim().toLowerCase()) >= 0) {
        return false;
    }
    return true;
}
function deduplicate(arr) {
    return [...new Set(arr)];
}
//# sourceMappingURL=options.js.map