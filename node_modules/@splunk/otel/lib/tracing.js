"use strict";
/*
 * Copyright Splunk Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.stopTracing = exports.startTracing = void 0;
const api_1 = require("@opentelemetry/api");
const sdk_trace_node_1 = require("@opentelemetry/sdk-trace-node");
const instrumentation_1 = require("@opentelemetry/instrumentation");
const http_1 = require("./instrumentations/http");
const logging_1 = require("./instrumentations/logging");
const options_1 = require("./options");
const semver_1 = require("semver");
const context_async_hooks_1 = require("@opentelemetry/context-async-hooks");
let unregisterInstrumentations = null;
function startTracing(opts = {}) {
    if (process.env.OTEL_TRACE_ENABLED === 'false') {
        return;
    }
    const options = (0, options_1._setDefaultOptions)(opts);
    // propagator
    api_1.propagation.setGlobalPropagator(options.propagatorFactory(options));
    // context manager
    const ContextManager = (0, semver_1.gte)(process.version, '14.8.0')
        ? context_async_hooks_1.AsyncLocalStorageContextManager
        : context_async_hooks_1.AsyncHooksContextManager;
    const contextManager = new ContextManager();
    contextManager.enable();
    api_1.context.setGlobalContextManager(contextManager);
    // tracer provider
    const provider = new sdk_trace_node_1.NodeTracerProvider(options.tracerConfig);
    configureInstrumentations(options);
    // instrumentations
    unregisterInstrumentations = (0, instrumentation_1.registerInstrumentations)({
        tracerProvider: provider,
        instrumentations: options.instrumentations,
    });
    // processors
    let processors = options.spanProcessorFactory(options);
    if (!Array.isArray(processors)) {
        processors = [processors];
    }
    for (const i in processors) {
        provider.addSpanProcessor(processors[i]);
    }
    // register global provider
    api_1.trace.setGlobalTracerProvider(provider);
}
exports.startTracing = startTracing;
function stopTracing() {
    unregisterInstrumentations === null || unregisterInstrumentations === void 0 ? void 0 : unregisterInstrumentations();
    unregisterInstrumentations = null;
    api_1.propagation.disable();
    api_1.context.disable();
    api_1.trace.disable();
}
exports.stopTracing = stopTracing;
function configureInstrumentations(options) {
    for (const instrumentation of options.instrumentations) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const instr = instrumentation;
        switch (instr['instrumentationName']) {
            case '@opentelemetry/instrumentation-http':
                (0, http_1.configureHttpInstrumentation)(instr, options);
                break;
            case '@opentelemetry/instrumentation-bunyan':
            case '@opentelemetry/instrumentation-pino':
            case '@opentelemetry/instrumentation-winston':
                (0, logging_1.configureLogInjection)(instr);
                break;
        }
    }
}
//# sourceMappingURL=tracing.js.map