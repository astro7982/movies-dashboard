"use strict";
/*
 * Copyright Splunk Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.EnvResourceDetector = void 0;
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const api_1 = require("@opentelemetry/api");
const core_1 = require("@opentelemetry/core");
const resources_1 = require("@opentelemetry/resources");
/* This is based on https://github.com/open-telemetry/opentelemetry-js/blob/main/packages/opentelemetry-resources/src/platform/node/detectors/EnvDetector.ts
 We're copying this code and changing the implementation to a synchronous one from async. This is required for our distribution to not incur ~1 second of overhead
 when setting up the tracing pipeline. This is a temporary solution until we can agree upon and implement a solution upstream.
*/
class EnvResourceDetector {
    constructor() {
        this._MAX_LENGTH = 255;
        this._COMMA_SEPARATOR = ',';
        this._LABEL_KEY_VALUE_SPLITTER = '=';
        this._ERROR_MESSAGE_INVALID_CHARS = 'should be a ASCII string with a length greater than 0 and not exceed ' +
            this._MAX_LENGTH +
            ' characters.';
        this._ERROR_MESSAGE_INVALID_VALUE = 'should be a ASCII string with a length not exceed ' +
            this._MAX_LENGTH +
            ' characters.';
    }
    detect() {
        try {
            const rawAttributes = (0, core_1.getEnv)().OTEL_RESOURCE_ATTRIBUTES;
            if (!rawAttributes) {
                api_1.diag.debug('EnvDetector failed: Environment variable "OTEL_RESOURCE_ATTRIBUTES" is missing.');
                return resources_1.Resource.empty();
            }
            const attributes = this._parseResourceAttributes(rawAttributes);
            return new resources_1.Resource(attributes);
        }
        catch (e) {
            const message = e instanceof Error ? e.message : e;
            api_1.diag.debug(`EnvDetector failed: ${message}`);
            return resources_1.Resource.empty();
        }
    }
    _parseResourceAttributes(rawEnvAttributes) {
        const attributes = {};
        const rawAttributes = (rawEnvAttributes || '').split(this._COMMA_SEPARATOR, -1);
        for (const rawAttribute of rawAttributes) {
            const keyValuePair = rawAttribute.split(this._LABEL_KEY_VALUE_SPLITTER, -1);
            if (keyValuePair.length !== 2) {
                continue;
            }
            let [key, value] = keyValuePair;
            // Leading and trailing whitespaces are trimmed.
            key = key.trim();
            value = value.trim().split('^"|"$').join('');
            if (!this._isValidAndNotEmpty(key)) {
                throw new Error(`Attribute key ${this._ERROR_MESSAGE_INVALID_CHARS}`);
            }
            if (!this._isValid(value)) {
                throw new Error(`Attribute value ${this._ERROR_MESSAGE_INVALID_VALUE}`);
            }
            attributes[key] = value;
        }
        return attributes;
    }
    _isValid(name) {
        return name.length <= this._MAX_LENGTH && this._isPrintableString(name);
    }
    _isPrintableString(str) {
        for (let i = 0; i < str.length; i++) {
            const ch = str.charAt(i);
            if (ch <= ' ' || ch >= '~') {
                return false;
            }
        }
        return true;
    }
    _isValidAndNotEmpty(str) {
        return str.length > 0 && this._isValid(str);
    }
}
exports.EnvResourceDetector = EnvResourceDetector;
//# sourceMappingURL=resource.js.map